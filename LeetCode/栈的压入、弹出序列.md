# 栈的压入、弹出序列

## 题目描述

> 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。

1. `0<=pushV.length == popV.length <=1000`
2. `-1000<=pushV[i]<=1000`

3. `pushV` 的所有数字均不相同

**示例1**

输入：

```
[1,2,3,4,5],[4,5,3,2,1]
```

返回值：

```
true
```

说明：

```
可以通过push(1)=>push(2)=>push(3)=>push(4)=>pop()=>push(5)=>pop()=>pop()=>pop()=>pop()
这样的顺序得到[4,5,3,2,1]这个序列，返回true      
```

**示例2**

输入：

```
[1,2,3,4,5],[4,3,5,1,2]
```

返回值：

```
false
```

说明：

```
由于是[1,2,3,4,5]的压入顺序，[4,3,5,1,2]的弹出顺序，要求4，3，5必须在1，2前压入，且1，2不能弹出，但是这样压入的顺序，1又不能在2之前弹出，所以无法形成的，返回false      
```

## 代码实现

```cpp
class Solution {
public:
    bool IsPopOrder(vector<int>& pushV, vector<int>& popV) {
        stack<int> st;   // 创建一个整型栈用于模拟入栈和出栈操作
        size_t popIndex = 0;  // 出栈序列的索引，用于跟踪已经匹配的出栈元素数量

        // 检查入栈和出栈序列长度
        if (pushV.size() != popV.size()) {
            return false;
        }

        for (const auto& elem : pushV) {
            st.push(elem);  // 将当前入栈元素压入栈中
            int topElement = st.top();  // 存储栈顶元素的值

            // 检查栈顶元素是否与出栈序列的下一个元素匹配
            while (!st.empty() && topElement == popV[popIndex]) {
                st.pop();          // 如果匹配，弹出栈顶元素
                ++popIndex;        // 并将出栈序列的索引移动到下一个元素
                if (!st.empty()) {
                    topElement = st.top();  // 更新栈顶元素的值
                }
            }
        }

        // 如果栈为空，表示所有元素都成功匹配，返回true
        // 否则，返回false，表示无法匹配所有元素
        return st.empty();
    }
};
```

## 解题思路

这段C++代码实现了一个函数 `IsPopOrder`，用于检查给定的入栈序列 `pushV` 和出栈序列 `popV` 是否匹配。

1. 创建一个整型栈 `st`，用于模拟入栈和出栈操作，以及一个整型变量 `popIndex`，用于跟踪已经匹配的出栈元素数量。`popIndex` 初始化为 0。

2. 首先，检查入栈和出栈序列的长度是否相同。如果它们的长度不同，直接返回 `false`，因为长度不同的入栈和出栈序列不可能匹配。

3. 遍历入栈序列 `pushV`，对于每个元素 `elem`：
   - 将当前元素 `elem` 压入栈 `st` 中，模拟入栈操作。
   - 获取栈顶元素的值，用 `int topElement = st.top();` 存储。

4. 检查栈顶元素是否与出栈序列 `popV` 的下一个元素匹配。如果匹配，执行以下操作：
   - 弹出栈顶元素，因为它已经成功匹配。使用 `st.pop();` 实现。
   - 增加 `popIndex` 的值，将出栈序列的索引移动到下一个元素，表示成功匹配了一个元素。
   - 如果栈不为空，更新 `topElement` 为新的栈顶元素的值，以便与下一个出栈元素进行比较。

5. 继续迭代遍历入栈序列，重复步骤 4 的操作，直到完成对整个入栈序列的遍历。

6. 最后，检查栈 `st` 是否为空。如果栈为空，表示所有元素都成功匹配，返回 `true`；否则，返回 `false`，表示无法匹配所有元素。

> 这个算法使用栈来模拟入栈和出栈操作，同时在匹配成功时将栈中的元素弹出，以确保出栈顺序正确。这是一种有效的方法来检查给定的出栈序列是否与对应的入栈序列匹配，如果匹配，返回 `true`，否则返回 `false`。