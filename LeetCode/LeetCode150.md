#  逆波兰表达式求值

# 题目描述

给你一个字符串数组 `tokens` ，表示一个根据 [逆波兰表示法](https://baike.baidu.com/item/逆波兰式/128437) 表示的算术表达式。

请你计算该表达式。返回一个表示表达式值的整数。

**注意：**

- 有效的算符为 `'+'`、`'-'`、`'*'` 和 `'/'` 。
- 每个操作数（运算对象）都可以是一个整数或者另一个表达式。
- 两个整数之间的除法总是 **向零截断** 。
- 表达式中不含除零运算。
- 输入是一个根据逆波兰表示法表示的算术表达式。
- 答案及所有中间计算结果可以用 **32 位** 整数表示。

 

**示例 1：**

> **输入：**tokens = ["2","1","+","3","*"]
> **输出：**9
> **解释：**该算式转化为常见的中缀算术表达式为：`((2 + 1) * 3) = 9`

**示例 2：**

> **输入：**tokens = ["4","13","5","/","+"]
> **输出：**6
> **解释：**该算式转化为常见的中缀算术表达式为：`(4 + (13 / 5)) = 6`

**示例 3：**

> **输入：**tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]
> **输出：**22
> **解释：**该算式转化为常见的中缀算术表达式为：
>   `((10 * (6 / ((9 + 3) * -11))) + 17) + 5`
> `= ((10 * (6 / (12 * -11))) + 17) + 5`
> `= ((10 * (6 / -132)) + 17) + 5`
> `= ((10 * 0) + 17) + 5`
> `= (0 + 17) + 5`
> `= 17 + 5`
> `= 22`

 

**提示：**

- `1 <= tokens.length <= 104`
- `tokens[i]` 是一个算符（`"+"`、`"-"`、`"*"` 或 `"/"`），或是在范围 `[-200, 200]` 内的一个整数

 

**逆波兰表达式：**

逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。

- 平常使用的算式则是一种中缀表达式，如 `( 1 + 2 ) * ( 3 + 4 )` 。
- 该算式的逆波兰表达式写法为 `( ( 1 2 + ) ( 3 4 + ) * )` 。

逆波兰表达式主要有以下两个优点：

- 去掉括号后表达式无歧义，上式即便写成 `1 2 + 3 4 + * `也可以依据次序计算出正确结果。
- 适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。

# 代码实现

```cpp
class Solution {
public:
    int evalRPN(vector<string> &tokens) {
        std::stack<int> st;

        for (const auto &str : tokens) {
            // 如果当前字符串是运算符
            if (str == "+" || str == "-" || str == "*" || str == "/") {
                // 弹出堆栈中的右操作数
                int rightNum = st.top();
                st.pop();

                // 弹出堆栈中的左操作数
                int leftNum = st.top();
                st.pop();

                // 调用 evaluateExpression 函数执行运算并获取中间结果
                int resultNum = evaluateExpression(str[0], leftNum, rightNum);

                // 将中间结果压入堆栈
                st.push(resultNum);
            } else {
                // 如果当前字符串是操作数，将其转换为整数并压入堆栈
                st.push(stoi(str));
            }
        }

        // 最终堆栈中仅剩一个元素，即计算结果
        return st.top();
    }

private:
    int evaluateExpression(char op, int left, int right) {
        // 根据运算符执行相应的运算
        switch (op) {
            case '+':
                return left + right;
            case '-':
                return left - right;
            case '*':
                return left * right;
            case '/':
                return left / right;
        }
        // 此处需要一个返回值（但是题目用例无误，任意返回值即可）
        return 0;
    }
};
```

# 解体思路

理解逆波兰表达式求值的关键是使用堆栈（stack）来跟踪操作数和运算符，并在遇到运算符时执行相应的计算。以下是更详细的解题思路：

1. 创建一个空堆栈 `st`，用于存储操作数和中间结果。

2. 遍历给定的字符串数组 `tokens`，这是一个逆波兰表达式，其中每个元素可以是操作数或运算符。

3. 对于每个字符串 `str`，执行以下操作：
   
   - 如果 `str` 是操作数，将其转换为整数（使用 `stoi` 函数），然后将整数压入堆栈 `st`。
   
   - 如果 `str` 是运算符，执行以下步骤：
   
     a. 弹出堆栈 `st` 的顶部元素，将其标记为 `rightNum`，这是右操作数。
     
     b. 再次弹出堆栈 `st` 的顶部元素，将其标记为 `leftNum`，这是左操作数。
     
     c. 根据运算符 `str` 执行相应的计算，将结果存储在 `resultNum` 中。例如：
     
        - 如果 `str` 是 "+"，则 `resultNum = leftNum + rightNum`。
        - 如果 `str` 是 "-"，则 `resultNum = leftNum - rightNum`。
        - 如果 `str` 是 "*"，则 `resultNum = leftNum * rightNum`。
        - 如果 `str` 是 "/"，则 `resultNum = leftNum / rightNum`。注意：在进行除法运算前，需要检查 `rightNum` 是否为零以避免除以零的情况。
     
     d. 将 `resultNum` 压入堆栈 `st`，以备后续运算使用。

4. 重复步骤3，直到遍历完整个字符串数组 `tokens`。

5. 在完成遍历后，堆栈 `st` 中应该只剩下一个元素，即计算的最终结果。

6. 返回堆栈顶部元素作为计算的结果。

这个算法利用堆栈数据结构来模拟逆波兰表达式的计算过程，依次处理操作数和运算符，最终得到正确的计算结果。堆栈在这里用来存储操作数和中间结果，以便在遇到运算符时能够正确地执行运算。