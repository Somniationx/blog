# 2023/10/4

## 排序算法

### 插入排序

#### 原理

工作原理：

1. **初始化**：算法从数组的第二个元素开始，将其视为已排序部分。初始时，第一个元素可以视为已排序部分，因为单个元素被认为是已排序的。

2. **遍历未排序部分**：从数组的第二个元素（下标为1）开始，依次遍历未排序的元素。将当前元素视为要插入已排序部分的元素。

3. **插入操作**：将当前元素与已排序部分的元素依次比较。如果当前元素小于已排序部分的元素，就将已排序部分的元素向后移动一个位置，为当前元素腾出插入的位置。这个过程会一直持续，直到找到当前元素的正确位置或已经将所有大于当前元素的元素都向后移动了。

4. **插入当前元素**：一旦找到了当前元素的正确位置，就将当前元素插入到已排序部分的合适位置。

5. **重复步骤 2~4**：然后继续遍历下一个未排序元素，并重复上述插入操作，直到遍历完所有未排序元素。在这个过程中，已排序部分逐渐增长，未排序部分逐渐减小，直到整个数组有序。

**算法的关键是在已排序部分内不断地向右移动元素以为新元素腾出插入的位置，然后将新元素插入到正确的位置。**

**由于插入排序的时间复杂度为O(n^2)，它对于小型数组通常效果很好，但对于大型数据集可能不是最佳选择。**

#### 代码实现

```cpp
void insertionSort(int arr[], int size) {
    for (int currentPos = 1; currentPos < size; currentPos++) { // Start from the second element and insert it into the sorted part
        int currentElement = arr[currentPos]; // The current element to insert
        int prevPos = currentPos - 1; // The position of the previous element

        // Find the correct position to insert the current element in the sorted part
        while (prevPos >= 0 && currentElement < arr[prevPos]) {
            arr[prevPos + 1] = arr[prevPos]; // Shift larger elements to the right
            prevPos--; // Continue comparing with the previous elements
        }

        arr[prevPos + 1] = currentElement; // Insert the current element at the correct position
    }
}

```

## 计算机网络

### 体系结构

#### `OSI`模型

1. **物理层（Physical Layer）**：
   - 主要职责是定义物理连接和传输介质（如电缆、光纤、无线信号）的规范。
   - 处理数据的比特流，负责数据的传输和接收。
   - 通常包括传输速率、电压电平、传输距离等特性的规定。

2. **数据链路层（Data Link Layer）**：
   - 主要职责是提供物理层上的可靠数据传输，检测和纠正传输中的错误。
   - 通常分为两个子层：逻辑链路控制（LLC）和媒体访问控制（MAC）。
   - MAC子层控制多个设备如何共享同一物理介质。

3. **网络层（Network Layer）**：
   - 主要职责是提供数据包的路由和转发，实现不同网络之间的通信。
   - 使用路由器等设备来确定数据包的最佳路径。
   - 典型的协议包括IP（Internet Protocol）。

4. **传输层（Transport Layer）**：
   - 负责端到端的数据传输，确保数据可靠地传输到目的地。
   - 提供错误检测和纠正、流量控制、拥塞控制等功能。
   - 典型的协议包括TCP（Transmission Control Protocol）和UDP（User Datagram Protocol）。

5. **会话层（Session Layer）**：
   - 管理会话（Session）或连接，提供数据传输的逻辑通道。
   - 处理会话建立、维护和终止，以及数据的同步。

6. **表示层（Presentation Layer）**：
   - 负责数据的编码、压缩、解码和解压缩，以确保数据格式的一致性。
   - 处理数据的加密和解密，以提供安全性。
   - 数据的翻译和格式化也在这一层处理。

7. **应用层（Application Layer）**：
   - 包含了网络应用程序和用户界面，提供用户与网络的交互接口。
   - 各种网络服务和应用程序，如Web浏览器、电子邮件、文件传输协议（FTP）等，都属于应用层。

> 这七个层次一起构成了计算机网络体系结构，也被称为OSI模型（Open Systems Interconnection model）。每个层次都有特定的功能，但它们之间是相互关联和协作的，以实现网络通信。不同的协议和技术被用于不同的层次，以确保网络的稳定性、性能和安全性。

#### **`TCP/IP`模型**

1. #### **网络接口层（Network Interface Layer）**：

   - 也称为链路层（Link Layer）。
   - 主要处理物理网络介质和数据链路的细节。
   - 包括硬件设备驱动、数据帧的构建和解析，以及MAC地址分配等功能。

2. **网络层（Internet Layer）**：

   - 主要职责是提供数据包的路由和转发，实现不同网络之间的通信。
   - 使用路由器等设备来确定数据包的最佳路径。
   - 核心协议是IPv4和IPv6，用于标识主机和路由器的地址。

3. **传输层（Transport Layer）**：

   - 与OSI模型中的传输层相似，负责端到端的数据传输。
   - 主要协议包括TCP和UDP，用于确保可靠的数据传输和错误检测。

4. **应用层（Application Layer）**：

   - 与OSI模型中的应用层类似，包括各种网络应用程序和服务。
   - 包括HTTP、SMTP、FTP、DNS等协议，用于实现各种网络应用。

**TCP/IP模型相对于OSI模型更加紧凑，通常被用于互联网和大多数网络通信。虽然OSI模型在学术和标准化方面更广泛使用，但TCP/IP模型在实际网络中更为普遍，因为它更贴近互联网的实际工作原理。**

> 需要注意的是，虽然TCP/IP模型仅包含四个主要层次，但它们仍可以与OSI模型中的一些层次进行对应。例如，网络接口层对应于OSI模型的物理层和数据链路层，网络层对应于OSI模型的网络层，传输层对应于OSI模型的传输层，而应用层对应于OSI模型的会话层、表示层和应用层。

### 物理层

#### 基本概念

#### 传输媒体

#### 传输方式

#### 编码与调制

#### 信道

## `CS：APP`



# 2023/10/06

## 数据结构

### `topK`问题模拟实现

### 堆排序

## C++

### `list`官方文档接口

### `list`初步模拟实现

## 计算机网络

### **可靠传输协议**

- 停止-等待协议
- 回退N帧协议
- 选择重传协议

### 点对点协议`PPP`

## English

### 四级单词`list2`

### 六级单词`list2`

## `Efective C++`

### 条款1

> 视C++为一个与语言联邦

### 条款2

> 尽量使用`const`, `enum`, `inline`替换 `#define`

# 2023/10/07

## English

### 四级单词`list3`

### 六级单词`list3`

## C++

### `list`模拟实现（常量迭代器）

## 数据结构

### 二叉树遍历

#### 前序遍历

#### 中序遍历

#### 后序遍历

#### 节点个数

#### 叶节点个数

#### 树高度

### Linux

### 进程地址空间

## `C++Primer`

### 第三章

#### `string`

#### `vector`

#### 数组

# 2023/10/08

## English

### 四级单词`list4`

### 六级单词`list4`

## C++

### `list`模拟实现完结

## `C++Primer`

### 第四章-表达式

## 线性代数

### 行列式

#### 行列式按行展开

#### 拉普拉斯定理

#### 异乘变零定理

#### 行列式相乘

## Linux

### 进程控制

#### 进程退出场景

#### 进程退出方式

### 进程等待

#### 进程等待概念

#### 进程等待方法

# 2023/10/09

## English

### 四级单词`list5`

### 六级单词`list5`

## `C++Primer`

### 第五章-语句

## Linux

### 进程控制

### 微型`shell`

## 线性代数

### 二阶三阶行列式

### n阶行列式

### 行列式的性质

## 离散数学

### 命题逻辑基本概念

### 命题公式及分类

### 命题逻辑的等值演算

## `EfectiveC++`

### 条款4
